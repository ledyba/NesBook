# 0x05: 一番簡単なパーツ：RAM

つなぐ部分が出来ましたから、パーツを組み上げます。どれから作ってもよいのですが、値の読み込みと書き込みさえ出来ればよい、6つのパーツの中では最も単純なパーツであるRAMから作りました。RAMへのアクセスはCPUの命令実行ごとに数回呼び出され、関数呼び出しのオーバヘッドが無視できないと思われるほど非常に多いので、こちらはすべてインラインで実装してみました。

src/emulator/VirtualMachine.h内に定義と実装があります。

```cpp
class Ram
{
public:
        enum{
                WRAM_LENGTH = 2048
        };
public:
        explicit Ram(VirtualMachine& vm) : VM(vm){}
        ~Ram(){}
        inline void onHardReset()
        {
                //from http://wiki.nesdev.com/w/index.php/CPU_power_up_state
                memset(wram, 0xff, WRAM_LENGTH);
                wram[0x8] = 0xf7;
                wram[0x9] = 0xef;
                wram[0xa] = 0xdf;
                wram[0xf] = 0xbf;
        }
        inline void onReset()
        {
        }
        inline uint8_t read(uint16_t addr)
        {
                return wram[addr & 0x7ff];
        }
        inline void write(uint16_t addr, uint8_t value)
        {
                wram[addr & 0x7ff] = value;
        }
protected:
private:
        VirtualMachine& VM;
        uint8_t wram[WRAM_LENGTH]; //2KB WRAM
};
```

親のVirtualMachineへの参照1のVMはRAMでは使っていないのでコンストラクタで引数として取る必要もないのですが、他のパーツでは必要になる2ため、一応デザインとして統一しておきました。

初期化はコンストラクタではなく、onHardResetと、onResetで行います。onHardResetは、「ファミコンの電源を付ける」動作に、onResetは「ファミコンのリセットボタンを押す」動作に対応します。処理を見ればわかる通り、実はこれらは似たようで違う挙動を示すようです。つまり、ハードリセット時はメモリの内容が0でクリアされ、一部アドレスに初期値が入るのですが、リセット時はメモリの内容はそのままです（だから、テニスとマリオを使った一部では有名な裏技3が成立します）。

onHardResetでの挙動は、コメントに書いてある通り、NESDEV Wikiを参照して書きました。ファミコンの挙動に関する調べた知識を実際にコードとして実装する際、その参照元を必ず書いておく事をお勧めします。後々のデバッグ時になって「このコードは本当に正しいのかな？」となった時、再度その情報源を読んで確認することができるからです。

## ビット演算で割り算の余りを求めて「ミラーリング」
さて、次はこのパーツの一応の核心部であるread/writeを見て行きましょう。アドレスの値をそのまま使うのでなく、0x7ffとandした結果にアクセスしています。なぜでしょう？
0x7ffは2047、つまりメモリの大きさである2048-1です。211-1なので、二進数で表すと0b11111111111となり、すべて1になります。これとandをすると、2048で割ったあまりが出ます。
```cpp
addr & 0x7ff == addr % 2048 //常に等しい
```

これが何故なのかは…2進数と10進数で考えれば分かります。andは、対応するビットがどちらも１なら1になる演算です。たとえば、11192と2047をandすることを考えましょう。

11192
0b10101110111000
2047
0b00011111111111
and
0b00001110111000

この結果をよく見て下さい。2047はずっと1が並んでいますから、andを取ると、2047で1が立っている下11桁の数字はすべて残り、0になっている12桁以降の数字はすべて0になります。2進数で考えると難しいかもしれませんが、10進数で考えると、どうでしょうか？23573の下３桁を残す処理は、具体的にはどのような処理でしょうか？

23573
***
253

はい、何のことはない、1000での割り算の余りです。このように考えれば、2047でのand⇔2進数で下11桁を残す処理⇔2048での割り算、というのが納得できるのではないでしょうか。
割り算は人間にとってもコンピュータにとって非常に重い処理なので、このように、できる限り高速なビット演算で代用します。実はそもそも、このようなビット演算はファミコン内の電子回路とまったく同じ方法だと言ってもよいです（ビット演算でなくて、12ビット目以降の値を無視している、と行った感じですが）。

さて、アドレスの2048での余りを取って、メモリにアクセスさせていました。

じつは、これがアドレスマップ（表 1、10ページ）に現れていた”ミラーリング”の正体なのです。

つまり、本当はRAMにはアドレス0x0000から0x7ffまででなく、0x0000から0x1fffまで割り当てられていて、この中で4回ループしている、というわけです（図 5）。

## 最後に、バスで繋げ合わせる

というわけで、初期化と読み書き、そしてミラーリングを実装し、やっとRAMが完成しました…。というわけで、このRAMをアドレスバスとつなげて、完成としましょう。
```cpp
inline uint8_t read(uint16_t addr) //from processor to subsystems.
{
  switch(addr & 0xE000){
    case 0x0000:
      return ram.read(addr); //追加
    case 0x8000:
    case 0xA000:
    case 0xC000:
    case 0xE000:
      return 0; //TODO: カートリッジ
    default:
      return 0; //TODO: まだたくさん残ってる
  }
}

inline void write(uint16_t addr, uint8_t value) // from processor to subsystems.
{
  switch(addr & 0xE000){
    case 0x0000:
      ram.write(addr, value); //追加
      break;
    case 0x8000:
    case 0xA000:
    case 0xC000:
    case 0xE000:
      // TODO: カートリッジ
      break;
    default:
      //TODO: まだたくさん残ってる
  }
}
```

さて、次はカートリッジです。