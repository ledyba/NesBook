# 0x04: 実装は丁寧に：まずは、バス

では、ソースコードの準備も整いましたから、実際に開発していきましょう！

何度も書いている通り、コンピュータの司令塔はCPUです。これを最初に書くと見通しが良くなるので、まずは”最低限CPUを走らせること”を目標にしましょう。この部分はエミュレータの基礎であり、また比較的テストしやすい部分なので、何度も何度も丹念にテストして、バグの無いようにします。

CPUを動作させるのに最低限必要なのは、CPU本体と、RAMとカートリッジ、そしてそれらとCPUをつなぐバス部分です。これらの４つがあれば、画面も音も出ないし、入力もできないけれど、カートリッジからプログラムを読んでRAMを読み書きする、最低限の”コンピュータ”の完成になります。

## アドレスに応じたパーツへの振り分け
CPUはカートリッジやRAMから命令データを読み込み、それを順々に実行していきます。ということは、まずはそのデータを読み出せないとどうしようもありません。そこで、バスを、最低限必要な部分から作っていきましょう。

この機能は、src/emulator/VirtualMachine.h内に

```cpp
uint8 VirtualMachine#read(uint16 addr)
void VirtualMachine#write(uint16 addr, uint8 val)
```

として実装してあります。

速度を稼ぐためにインライン関数として実装しました。
```cpp
inline uint8_t read(uint16_t addr) //from processor to subsystems.
{
  switch(addr & 0xE000){
    case 0x0000:
      return 0; //TODO: RAM
    case 0x8000:
    case 0xA000:
    case 0xC000:
    case 0xE000:
      return 0; //TODO: カートリッジ
    default:
      return 0; //TODO: まだたくさん残ってる
  }
}
```

以上が読み込み側です。

同じように、書き込み側も作成します。読み込む場合とと書き込む場合で、同じアドレスでも宛先のパーツや機能が異なる場合があるので（後々出てきます）、関数は多少冗長になっても読み書きで違うものにします。

```cpp
inline void write(uint16_t addr, uint8_t value) // from processor to subsystems.
{
  switch(addr & 0xE000){
    case 0x0000:
      // TODO: RAMへの書き込み
      break;
    case 0x8000:
    case 0xA000:
    case 0xC000:
    case 0xE000:
      // TODO: カートリッジ
      break;
    default:
      //TODO: まだたくさん残ってる
  }
}
```

アドレスの振り分けに使っているswitch文は、いったいどういう意味なのでしょう？アドレスマップ（表 1）の開始アドレスを、２進数にしてよく観察してみましょう（表 2）。
0xE000 = 0b1110000000000000とandを取ると、andを取った値のうち、赤字の部分と同じ桁のビットだけが残り、あとは全て0になります。これを踏まえて、各バスの開始アドレスの表を見ましょう。

各開始アドレスのうち、赤で示した上位3ビットだけを見ることで、割りと分類することができそうです。

0x0000と0x0800、0x2000と0x2008のような、ミラーリングアドレスと元のアドレスとは上位3ビットだけでは区別できませんが、後で見るとおり、実はこれらは区別する必要がありませんので、大丈夫です。

0x4000と0x4020も区別できていませんが、これは上位3ビットだけで振り分けてから、再度振り分けるほうが、全体としてはコードは綺麗になりそうです。
という訳で、上位3ビットだけ1にした0b1110000000000000=0xE000とアドレスをandして上位3ビットだけ取り出し、その値でswitch文で振り分けた、というわけです。
エミュレータでは、こういったビット演算が多用されます1。慣れておいてくださいね。
