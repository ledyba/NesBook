# 0x07 一番重要だけど、一番素直なパーツ：CPU

というわけで、やっと司令塔であるCPUです！CPUが一番難しそうなイメージがありますが、CPUを再現するには、少数のルールを正確に実装すれば、実は単純作業に成り下がってしまいます。あんまり気負わずに、気楽にやっていきましょう。

## CPUって、何から出来てる？
すごく基本的な話から始めましょう。CPUは私たちが買うときは1つのチップとして販売されていますが、このCPUは、いったいどのようなパーツからできあがっているのでしょう？
エミュレータを作るという観点からみたCPUは、以下の二つの部分から出来ています。
 - 命令解釈部
 - レジスタ

命令解釈部は、その名の通り、いわゆる機械語を解釈してどういうプログラムが書かれているのかを理解する部分です。

レジスタは、途中の計算結果を格納したり、現在のCPUの状態を表すために使う、せいぜい数十バイトの小さな小さなメモリです。


## CPUの基本的な動作

CPUの基本動作は、
 1. プログラムカウンタという特殊レジスタの示すアドレスから、命令を表す数値を読み込む
 2. 命令に応じて、CPU内のレジスタ、あるいはバスを通じてメモリを読み書き・計算する
 3. 1に戻って繰り返す。割り込みがあったら所定の手続きでISR（割り込みハンドラと呼ばれるプログラム）の実行に移る

これの繰り返しだけです。もしも8文字だけでプログラムを書ける超簡易言語Brainfuck1をご存知なら、その規模を大きくしただけ、と言っても過言ではありません。Brainfuckのインタプリタの実装の経験がお有りなら、きっとすんなりとCPUのエミュレーションも出来るでしょう。

## ファミコンのCPU、6502のもつレジスタ
 ファミコンのCPUは、MOS 6502でした。6502を表すクラス、Processorのメンバを考えるために、まずはこのCPUの持つレジスタを知りましょう。

こんな感じです。

|レジスタ名|ビット数||
|:--|:--|:--|
|A|8ビット|アキュームレータ。途中の計算結果を格納する。|
|X,Y|それぞれ8ビット|インデックスレジスタ。アドレスの計算に使う。|
|PC|16ビット|現在実行中の命令のアドレスを示す。|
|SP|8ビット|CPUが持つスタック（0x0100->0x01ff）の、一番下のアドレスの下位8ビットを示します。|
|P|8ビット|それぞれのビットがCPUの動作状態を表すフラグです。NVBDIZCの7つのフラグがあります。|

各命令の実行ごとに、これらのレジスタ、あるいはバスを通じてメモリが書きかえられていくのが、6502というCPUの基本的な動作と言うことになります。

以上を使って、基本的なProcessorクラスの定義を作ったのがこちらです。

```cpp
class Processor
{
        public:
                explicit Processor(VirtualMachine& vm);
                ~Processor();
                void run(uint16_t clockDelta);
                void onHardReset();
                void onReset();
        protected:
        private:
                inline uint8_t read(uint16_t addr); // VMの同関数を呼ぶラッパ
                inline void write(uint16_t addr, uint8_t value); // VMの同関数を呼ぶラッパ
                //定数
                enum{
                        FLAG_C = 1,
                        FLAG_Z = 2,
                        FLAG_I = 4,
                        FLAG_D = 8,
                        FLAG_B = 16, //not used in NES
                        FLAG_ALWAYS_SET = 32,
                        FLAG_V = 64,
                        FLAG_N = 128,
                };
                VirtualMachine& VM;
                uint8_t A;
                uint8_t X;
                uint8_t Y;
                uint16_t PC;
                uint8_t SP;
                uint8_t P;
};
```

ハードリセット・ソフトリセット時の処理はNESDEV WikiやNES on FPGAの各ページ3にあるので、この通りに実装しておきました。Processor.cppに実装があります。

ステータスレジスタBは、本来の6502では、「二進化十進表現」計算モードであるか否かを判別するフラグなのですが、ファミコンの6502ではこの機能は不要とされ、削除されています（フラグをセット・解除してモード変更は形式上できるのですが、実際にはモードは変わりません）。

## 機械語の読み方

というわけで、次に機械語を読み取って実行する、命令解釈部の実装に移りましょう。6502の機械語は、１つだけ取り出すと次のような姿をしています。

…なぜ図にしてしまったのか、後悔するほどに簡単です。各命令は、「どんな命令か」、つまり私たちの自然言語で言えば、「動詞」を表すオペコード１バイトと、「どの対象に向けての命令か」、つまり「目的語」を表すオペランド0～1つ（有る場合は1バイトか2バイトの可変長）を取ります。

抽象的で分かりづらいですね。具体的な例を見ましょう。
```
0x69 0x44
```
これを、もう少し分かりやすい、「アセンブリ言語」で表すと、こんな感じ。
```asm
ADC #$44
```

この2バイトの最初の1バイト目「0x69」でこの命令が「ADC命令」である事を表します。ADC命令は、オペランドの表す値を、プロセッサのAレジスタに足す、という命令です。この場合は、機械語に直接書かれた「0x44」をそのままAレジスタに足す、と言うことになります。

最初の１バイト目0x69が「ADC命令」を表すと書きましたが、この0x69というバイトは、この例のように、機械語に直接書かれた値（「イミディエイト」と表現します）を足すADC命令を表す場合の数値で、同じADC命令でも、最初の1バイト目の数値は違う場合があります。その場合、Aレジスタに足される値が何なのかが変化します。次の例を見ましょう。

```
0x7D 0x00 0x06
```
これを同様にアセンブリ言語で表記すると、

```asm
ADC $0600,X
```

これはこんな意味です（よく分からなかったらこの行は飛ばしてください）：「二バイト目と三バイト目を”リトルエンディアン”、つまり２バイト目を下位8ビット、３バイト目を上位8ビットとする16ビットの値として解釈し（＝$0600）」、「それにプロセッサのXレジスタを足した値のアドレス（例えばX＝0x78なら、0x0678）を使ってバスから値を読み出し」、「その値をAレジスタに足す」。

前の例に比べると非常に複雑になりましたが、「どこからか持ってきた値を」「Aレジスタに足す」という点では、共通しています。違いは、その値を機械語の値を直接使うのか、機械語からの値を足し引きして持ってきたものを使うかどうか、です。この「どこから持ってくるかの違い」を、アドレッシングモードと呼びます。同じADC命令でも0x69と0x7Dと1バイト目が違うのは、このアドレッシングモードの違いを表しているのです。

### 0x0705 6502のアドレッシングモード
さて、このようなアドレッシングモード、私たちの実装する6502には、「オペランドなし」も含めると11個あります。

一応列挙するとこんな感じ。詳しく解説してもしょうがない（本当に書かれてるとおりにするだけ）ので、NES on FPGAのCPUの項目4に解説は譲ります。

 - オペランドなし：cli（iフラグクリア）など、オペランドを指定する必要のない命令
 - Immediate、イミディエイト：機械語に書かれたオペランドの8ビット値そのまま
 - Zero Page、ゼロページ：上位8ビット0x00、下位8ビットが機械語に書かれたオペランドの8ビット値であるアドレスを使う（つまり、範囲は0x0000->0x00ffになります）。6502の超有名機能。
 - Absolute、絶対番地：オペランドの示す16ビットのアドレスを使う
 - Zero Page X、Zero Page Y：
先述のゼロページでのアドレスに、XレジスタかYレジスタを足してつかう。
 - Absolute X、Absolute Y：
先述の絶対番地に、XレジスタかYレジスタを足して使う。
 - Relative: 分岐命令で使う特殊アドレッシングです。
 - Indirect X：ゼロページXのアドレスから値を連続で2バイト、リトルエンディアンで読み込み、その2バイトをアドレスとして使います。
 - Indirect Y：ゼロページの値から2バイト、リトルエンディアンで読み込み、その2バイトにYレジスタを足したものを使います。

いまいち分からない？大丈夫です！先述のNES on FPGAに自然言語での説明が、そしてNESDEVドキュメント5には実例を交えて詳しく解説されたものがあります。これを読んだままをソースコードに表現すれば、大丈夫です。

## オペコードとオペランドを、分離して実装する

さて、同じ「足し算」の命令でも、アドレッシングモードによって、動作が変わることが分かりました。私たちのエミュレータでも、同じように、「命令」と「アドレッシングモード」の部分を分けて実装することで、同じようなコードが連続するのを避け、見通しよく実装しましょう。

各命令は、アドレッシングモードによって得た16ビットのアドレスを取って動作する、一種の関数であると見なす事ができます6。この関数としての命令の動作について、疑似言語を用いた非常に詳しい解説が、NESDEVのドキュメントにあります7。これを見れば、各命令についてほぼ迷いなく実装することができます。これは```Processor#ADC(const uint16_t addr)```などをご覧ください。

アドレッシングモードは、今度はPCレジスタから命令を読み取って加工したアドレスを返す、関数とみなせます。こちらは```uint16_t Processor#addrImmediate()```などに実装しました。
さて。あとはこれらを組み合わせて、各命令を解釈＆実行するだけです！

## オペコード分岐255個をswitch文で。ぶっちゃけ、根性。

では、命令の具体的な解釈は、どう実装すれば良いのでしょう？

各命令の最初の1バイト目のオペコードによって、命令の種類と使用するアドレッシングモードが区別されているとお話しました。一番てっとり早いのは、これを全部そのまま、switch文で振り分けてしまうことです。デバッグも簡単ですし、数は多いですが気合いでなんとかなります。

先述のドキュメントの中盤に、この対応があるので、これをエディタなどで加工しつつ、255個のswitch文に書き換え、他の処理を加えたのが、こちら。

```cpp
void Processor::run(uint16_t clockDelta)
{
    this->P |= FLAG_ALWAYS_SET;

    const uint8_t opcode = this->read(this->PC);
    #define CPUTRACE // 命令のトレースログを出力
    #ifdef CPUTRACE
    char flag[9];
    flag[0] = (this->P & FLAG_N) ? 'N' : 'n';
    flag[1] = (this->P & FLAG_V) ? 'V' : 'v';
    flag[2] = (this->P & FLAG_ALWAYS_SET) ? 'U' : 'u';
    flag[3] = (this->P & FLAG_B) ? 'B' : 'b';
    flag[4] = (this->P & FLAG_D) ? 'D' : 'd';
    flag[5] = (this->P & FLAG_I) ? 'I' : 'i';
    flag[6] = (this->P & FLAG_Z) ? 'Z' : 'z';
    flag[7] = (this->P & FLAG_C) ? 'C' : 'c';
    flag[8] = '\0';
    printf("%04x op:%02x a:%02x x:%02x y:%02x sp:%02x p:%s IRQ?:%s NMI?:%s\n", this->PC, opcode, this->A, this->X, this->Y, this->SP, flag, IRQ ? "on" : "off", NMI ? "on" : "off");
    fflush(stdout);
    #endif
    this->PC++;

    switch(opcode){
        case 0x00: // BRK
            this->BRK();
            break;
        case 0x01: // ORA - (Indirect,X)
            this->ORA(addrIndirectX());
            break;
        //case 0x02: // Future Expansion
        //case 0x03: // Future Expansion
        //case 0x04: // Future Expansion
        case 0x05: // ORA - Zero Page
            this->ORA(addrZeroPage());
            break;
                /* 中略 */
        default:
            throw EmulatorException("[FIXME] Invalid opcode!");
    }
    consumeClock(CycleTable[opcode]);
}
```

割り込みは複雑なので、まだ実装していません。
フラグPは必ずセットされる仕様だそうなので、一応セットしておきました。無くてもたぶん動きます。その次に命令の実行ログを出力していて、これは、次の項でテストに使います。

### プログラムカウンタの進め方

命令を正確に実行するには、１命令を実行するごとに、正確にその命令分、プログラムカウンタを追加する必要があります。おさらいすると、オペコードが１バイトで、オペランドが0～2バイトでしたから、命令ごとに1～3バイト分加算する必要があります。すべての命令でオペコードとして必ず１バイト使う分は、共通で加算しておきます。デバッグメッセージ出力の次の行です。

残りのオペランドの１～２バイトは、アドレッシングモードだけに依存して変わるので、各アドレッシングモードの関数内で加算します。例えば、インダイレクトXはこのような感じ。

```cpp
inline uint16_t Processor::addrIndirectX()
{
     uint8_t idx = read(this->PC) + this->X;
     this->PC++;
     uint16_t addr = read(idx);
     idx++;
     addr = addr | (read(idx) << 8);
     return addr;
}
```

インダイレクトXは、オペコードの次の１バイトとXレジスタを組み合わせて値のアドレスを計算するので、オペランドの１バイト分を二行目で加算しています。１行目でread(this->PC++)とすると行を分ける必要もなく、これはこれでスッキリするのですが、X++と++Xの区別はたまに間違えるので、今回はやりません。

### クロック数＝実行時間を正確に記録しよう

最後のconsumeClock()が気になりますね。各命令や各アドレッシングモードで掛かる命令クロック数をカウントして、親のVirtual Machineに伝える関数です。これも各命令ごとに異なります。加算されるクロック数はアドレッシングモードだけでなく、オペコードごとに異なるので、すべてのオペコードについてクロック数を計算してあるテーブルを用いて、加算しています。

基本的には同じオペコードなら同じクロック数なのですが、たまに時間が異なります。その分はクロック数の延長が発生する部分で個別に足してます。例えば、IndirectYを見てみましょう。

```cpp
inline uint16_t Processor::addrAbsoluteIdxY()
{
  uint16_t orig = read(this->PC);
  this->PC++;
  orig = orig | (read(this->PC) << 8);
  this->PC++;
  const uint16_t addr = orig + this->Y;
  if(((addr ^ orig) & 0x0100) != 0){
    consumeClock(1);
  }
  return addr;
}
```

インダイレクトYでは、PCに続く２バイトをアドレスとして解釈し、さらにそのアドレスにYレジスタを足した結果が、最終的なアドレスとなります。このYを足した時に、アドレスの最初の１バイトが増える”繰り上がり”が発生していると、内部回路の都合で実行時間が１クロックだけ増えてしまいます。これを、「(addr ^ orig) & 0x0100) != 0」という部分で検出しています。

^演算子は”xor”と呼ばれるもので、ビット同士を比較して異なっていたビットだけが1になります。

さて、もし、繰り上がりが起こっていた場合、Yレジスタは1バイト、0から255までの値を取りますので、アドレスの上位１バイトは最高でも1しか増えません。例えば、0x10ffに0xffを足しても0x11feとなり、１しか増えていないと確認できます。

上位１バイトが高々１しか増えないということは、繰り上がりが発生していた場合、上位１バイトの一番下の1ビットは必ず書き換わります。

0x10ff = 00010000 11111111
0x  ff =          11111111
0x11fe = 00010001 11111110

この変化を調べるために、まず足す前と足した後をxorすることで、変化したビットを調べます。

さらに調べたいビットだけに1を設定した0x0100とandを取ると、調べたいビットが変化していたときだけ、0以外の値になり、これで繰り上がりで上位１バイトの一番下の1ビットが変化したかを調べられる…というわけです。

それをまとめたのが、この「(addr ^ orig) & 0x0100) != 0」という条件式です。

## ネット上のテストROMを使って、テストしよう。

さて、このCPUエミュレータを延々テストしましょう。NESDEVには、なんとCPUのエミュレータをテストするための専用のROMが配布されています！流石は有名なファミコンです。

このROMを0xC000から実行して（onHardResetあたりに、PCを0xC000で初期化するコードを一時的に書きましょう）、その動作ログを、同ページからDLできる正しい動作ログと見比べて、少しでも違いがあればバグだよ、というわけです。…でも、その動作ログ、結構間違ってます。他のエミュレータと多数決とった結果と違うし、CPUの仕様書と比べても変な挙動なところが散見されます。

というわけで、github.com/ledyba/NesBook/doc/nestest_trace.logに、FCUEXというエミュレータから私が取った（たぶん）正しい動作ログがあるので、これを使ってください。

これと、先述の #ifdef CPUTRACE以下に書いたデバッグコードを有効にしてコンパイルして実行するとコンソール画面に延々と実行されている命令が出力されるので、見比べましょう。

コマンドラインで、次のように実行すると、その動作ログをファイルに保存する事ができます。

$ [エミュレータ] nestest.nes > [動作ログ]

さて、この動作ログをnestest_trace.logと1行1行見比べてデバッグします。普通にやると、とても大変そうです…。

でも大丈夫。Notepad++9などにある、画面を2分割して別のテキストを開きつつ、二つのテキストのスクロールを同期するモードを使って見比べましょう。どちらの動作ログも、1命令実行1行、なので、同じ行には同じアドレスの同じ命令が表示されるはずです。違ったら、バグなので直しましょう。ただ、本当に１行１行見ていくのはとても骨が折れる作業で、数万行の行のどこから食い違っているのかを探すのは本当に大変です。

そこで簡単なコツとして、「二分探索」があります。動作ログの１万行目を見て、正しい結果と異なっていた場合、0行目から1万行目のどこかで違っているはずですが、気が遠くなりますね。こんなときは、少しずつ範囲を絞って行きましょう。具体的には、こんな感じ：

1. 0行目と1万行目の間の、5000行目が間違っているかどうか、調べます。
ここでは合っていたので、多分この後だと見当がつきます。
2. さらに、5000行目と1万行目の間の、7500行目を調べます。
ここでは間違っていたので、5000行目と7500行目の間のどこかから間違っています。
3. 5000と7500の間にある、6700行目くらいを調べます。
ここでは合っていたので、この後から7500行目のどこかにあります。
4. 1000行の間のどこかまで絞れたので、ここからは1行ずつ調べてしまいましょう。

このようにすれば、比較的短時間で間違った場所を特定できるので、おすすめです。

ここで動作が違っている場所が直接的にはバグの原因なので、その命令を調べてみましょう。ただし、いくつか（ひょっとすると数千も）前の命令でのバグの影響が、たまたまその命令で表面化していることもあるので、表面化しているところの命令の実行にバグが無さそうに見えたら「表面化したときの命令がどの状態（たち）に依存しているか」を調べて、どの状態が何だったら期待通りに動いていたかを考え、その状態はどこで書き換わるかを追いかけて行くとデバッグ出来なくはないですが、言うほど簡単ではないです。

このCPU実行ログを見比べててデバッグする方法は、他のモジュールをデバッグする際にも使った、基本的（？）な方法なので、ぜひやってみてください。デバッグが完了すれば、これで「最低限のコンピュータ」が完成したことになります。
