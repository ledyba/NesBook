# 0x06: とりあえず仮で、動けばいいや：カートリッジ

とりあえず仮で、動けばいいや：カートリッジ

[Chapetr3](chapter3.md) で動かしたように、カートリッジは「.NES」という拡張子のファイルを読み込みます。まずはこのファイルと、現実のカートリッジとの対応関係を考えましょう。

## ファミコンのROMファイルって、どうなってるの？

ファミコンのカセットの中には、ROMが入っています。Read Only Memoryの名が示すとおり、読み込みだけで、書き込みのできないメモリーチップです。これはいわゆる「カートリッジ」で動くゲーム機で共通する特長ですが、さらにファミコンにはこのROMに二種類あるという特徴があります。

それは「プログラムROM」と「キャラクタROM」と呼ばれています。名前が示すとおり、プログラムROMにはCPUの実行するプログラムが、キャラクタROMには、画面上に表示される画像データが、それぞれ格納されています。

パソコン上では一つのファイルである.NESファイルは、この２つのROMの中身を統合したものなのです（図 6）。

カートリッジの基板の上では、ファミコン本体とつなぐバスや物理的なチップが、それぞれのROMで独立して存在しています。メモリーマップ（表 1、10ページ）上の「カートリッジ」とあった部分は、実はプログラムROMだけで、キャラクタROMはPPU（ビデオ）がCPUとは別に持っているバスと繋がっています。PPUのバスはCPUから直接は利用できず、CPUのバスからPPUにアクセスし、PPUを経由するという間接的な方法でしか、キャラクタROMにアクセスできません。

そういえばドラクエⅢなどに搭載されている、セーブデータ用のRAMはどうなっているのでしょう？

このRAMもプログラムROMやキャラクタROMとは別のチップですが、キャラクタROMと共通のバスを利用しています。そのため、CPUからアクセスでき、アドレスマップに「セーブデータ用RAM」領域として存在しているのです。

## .NESファイルにも、フォーマットがある
ファミコンのROMが２つの独立した部分から成り立っていて、それらの異種のデータを一つのファイルに纏めている以上、.NESファイルにも所定のファイルフォーマットがあります。それが、iNES1フォーマットと呼ばれているフォーマットで、この業界（？）のデファクトスタンダードです。

エミュレータ界隈で生まれた野良フォーマットなので、「標準」とかは基本的にありません。自分でゲームデータをカートリッジから吸い出して、自分のエミュレータで走らせるだけなら、自分でiNESフォーマットに変わるものを開発してしまって、全然構わないのです。

でもまあ、自分で考えるのも大変ですし、PDRomsのような自作ゲームは大抵iNESフォーマットでリリースされているので、私達のエミュレータもこのフォーマットを採用してしまいましょう。

### 正確な仕様書のないフォーマット

このiNESフォーマット、標準化機関がもちろん標準化したりはしていません。また、オリジナルのiNESフォーマットをいろいろな人が勝手に拡張してしまっているので、「これ！」という仕様書はありません。ので、フォーマットが解説されている誰かの書いた”仕様書”を、私たちのエミュレータで必要な程度に、適当に実装しておけば、まあ大丈夫です（ぇ。

今回は、Everynes2の仕様書と、NESDEV Wikiのフォーマットを解説した項目3を適当に参照しながら実装しました。
そのパーサーとなるクラスNesFileは、カートリッジを表すクラスCartridgeとは別に、Cycloa/src/emulator/file/NesFile.h、同NesFile.cに定義・実装しました。後々ビデオやサウンドを実装するときにわかるのですが、カートリッジは単にROMデータを持っている他にもいくつか役割があります。それらをうまく抽象化するために、ファイルの内容を持っている部分と、カートリッジ本体は分けて実装することにしました。

ソースコード自体はバイナリデータをパースするだけなので、特に解説する点はありません。iNESフォーマットは、最初の10バイトがヘッダで、その後に具体的なデータが格納されているデータです。

この中に、仕様書に示してあるとおり、いくつかフラグやパラメータが記述されています。以下に、それらの値について、軽く説明します。

#### マッパー番号（Mapper Number)

ファミコンのカートリッジの中身は、ソフトによって違う事があります。例えば大容量のROMを積んでいたりする場合です。それらを区別するための番号がこちらです。
当面は一番簡単なMapper0を使うでしょう。後で詳しく解説します。

#### Four-screen VRAM Layout
#### Horizontal Mirroring/Vertical Mirroring

この２つは、PPU（ビデオ）を実装する際に詳しく検討しましょう。ビデオ用のメモリにも、前実装したRAMのようなミラーリングがあり、それを指定するフラグです。

#### Battery-packed SRAM

0x6000-0x7fffのセーブデータ領域に現れる、SRAMが存在するかどうかのフラグです。このフラグが立っている場合は、この領域が読み書きできて、電源を切ってもデータが残る、と言うことになります。が、今回のエミュレータでは、保存するのが面倒なのでエミュレータを終了させるとセーブデータも消えてしまいます。

#### Trainer
その昔、まだエミュレータの完成度が低かった頃、エミュレータで市販ゲームをうまく動作させるために、ROMへの修正が必要だった時代があり、その修正パッチをTrainerと呼んでいたようです。自分で吸い出したROMや、自作ゲームを遊ぶにはいらない項目です。元のiNESフォーマットにもあるようなので、今回の実装でも一応解釈していますが、使っていません。

他は後々に付け加えられた拡張的な部分なので、無視でいいと思います。

## マッパーって？
さて、iNESのマッパー番号で表される”マッパー”は、カートリッジの種類のことでした。なぜ、複数種類のカートリッジの基板が必要なのでしょう？普通に考えると、一種類に統一してしまえば量産が効いて安くなるし、技術的にもスッキリするのではないでしょうか？

これも、メモリーマップ（表 1、10ページ）を見ながら考えていけばわかります。プログラムROM領域は0x8000から0x7fffで、サイズは32KBです。ファミコンの時代を考えると結構多いように見えます。
たしかに、マリオやサッカーなど、初期のゲームはその程度の容量でも間に合っていたのですが、ファミコンの成熟によってソフトに必要な容量が増えてきました。例えばDQ4は512KBもあります。伝説のクソゲー「チーターマンⅡ」の乗っているAction53のROMは2MBくらいあるそうです。

32KBしか載せられないはずのメモリ空間に、どうして大容量が実現できるのか？
答えはこうです：「同じメモリアドレスが常にカートリッジ内の同じ場所を指している必要はない」。

メモリコントローラと呼ばれるパーツをCPUとカートリッジの間に載せて、同じメモリ・アドレスに、カートリッジの別の場所を割り当てて、必要に応じて実際にはどこにアクセスするのかを切り替えられるようにしてしまいました（エラー: 参照先が見つかりません。）。これを「バンク切り替え」と呼びます。32KBの領域をN個のバンクで切り替えれば、N×32KBものの大容量が使える、というわけです。

…が、たしかに増やせるのですが、同時に扱うことが出来るデータはやはり32KBしかありません。このバンク切替えはプログラムROMだけでなく、キャラクタROMでも使われるのですが、キャラクタROMは画面表示に使われ、グラフィックはCPUとは別に独立して動作するため、「同時」の条件がプログラムROMよりシビアになります。

このバンク切替方式も統一すれば良いのに…と思うのですが、実際には各社が様々なチップ（任天堂ですら、何種類も出しています）を開発し、ファミコンの様々なゲームに使われました。

特殊カセットは「バンク切り替え」だけのためのものではありません。実はカセット端子には音声入力・出力もあり4、もともとのファミコン音源を超える綺麗な音を表現するために、カセット内に独自の音源チップを積んでいる場合があります（「ラグランジュポイント」のVRC7は特に有名です！）。

さらに独自のタイミングで割り込みを発生させるための端子もあり、この割り込みを利用して、綺麗な画面効果（ラスタースクロールなど）を実現しているソフトも、結構あります。

いろいろな特殊カートリッジ（マッパー）があることが分かって頂けたと思いますが、当面は私たちはマッパー0のみを扱いましょう。このマッパーは、ROMチップをカートリッジ上にただ単に載せただけのマッパーで、プログラムROMは32KB、キャラクタROMは8KBのメモリ空間の上限までしか載せることができません。

## マッパーの抽象化は考えずに、マッパー0だけ実装しておく。
カートリッジは、思いの外沢山の機能を担っていることがわかりました。となると、あまりファミコンハードに詳しくない私達には、いきなりカートリッジの抽象化を行うのは、ちょっと荷が重いですね。まずは、マッパー0、しかも、CPUを動かすのに必要な、CPUメモリからアクセスされる部分だけを実装しましょう。
とりあえず、ヘッダでの定義はこんな感じにしてみました。
```cpp
class Cartridge
{
        public:
                Cartridge(VirtualMachine& vm, const NesFile* nesFile);
                virtual ~Cartridge();

                /* for CPU */
                uint8_t readBankHigh(uint16_t addr);
                void writeBankHigh(uint16_t addr, uint8_t val);
                uint8_t readBankLow(uint16_t addr);
                void writeBankLow(uint16_t addr, uint8_t val);
                inline uint8_t readSram(uint16_t addr) const
                {
                        if(hasSram){
                                return this->sram[addr & 0x1fff];
                        }else{
                                return 0;
                        }
                }
                inline void writeSram(uint16_t addr, uint8_t value)
                {
                        if(hasSram){
                                this->sram[addr & 0x1fff] = value;
                        }
                }
        //TODO: もっとたくさんの関数が後々に必要になる
        protected:
                const NesFile* const nesFile;
        private:
                VirtualMachine& VM;
                bool hasSram;
                uint8_t sram[SRAM_SIZE];
                const uint16_t addrMask;
};
```

セーブ用のRAMは、ROMデータを表すNesFileとは分離して持つことにしました。もしNesFileのSRAMを持っているフラグが立っている場合、このカートリッジ内のhasSramもフラグが立ち、SRAMへの読み書きが有効になるというわけです。もっと面倒な場合は、SRAMフラグの有無にかかわらずSRAMを使用可能にしてしまっても、大丈夫だとは思います。

さて、今度は実装です。

```cpp
Cartridge::Cartridge(VirtualMachine& vm, const NesFile* nesFile) :
        nesFile(nesFile),
        VM(vm),
        hasSram(nesFile->hasSram()),
        // 16KBなら、同じ内容が繰り返される
        addrMask(nesFile->getPrgPageCnt() > 1 ? 0x7fff : 0x3fff)
{
        if(nesFile == NULL){
                throw EmulatorException("NES FILE CAN'T BE NULL!");
        }
}
Cartridge::~Cartridge()
{
        if(this->nesFile){
                delete this->nesFile;
        }
}


/* for CPU */
uint8_t Cartridge::readBankHigh(uint16_t addr)
{
        return this->nesFile->readPrg(addr & addrMask);
}
void Cartridge::writeBankHigh(uint16_t addr, uint8_t val)
{
        //have no effect
}
uint8_t Cartridge::readBankLow(uint16_t addr)
{
        return this->nesFile->readPrg(addr & addrMask);
}
void Cartridge::writeBankLow(uint16_t addr, uint8_t val)
{
        //have no effect
}
```

プログラムROMの読み書き関数が二つに分かれていますが、これは先述のJavaScriptでのエミュレータを参考にしてのことで、0x8000-0xbfffの前半がLow、0xc000-0xffffの後半がHighの関数の範囲です。最後まで作って分かりましたが、このようにするとすんなりと書ける時もあったり無かったり、です。一つにまとめても良いと思いました。

マッパー0はプログラムROMが16KBのときと、32KBのROMの時があります。32KBの場合はアドレス領域をすべて使い切るのですが、16KBの時は、16KBの内容が二回ループします。そう！RAMのミラーリング（19ページ）と同じです。nesFile->getPrgPageCnt()は、iNESファイルで16KBごとのカウントである「ページ数」を返すので、この値を使ってaddrMaskを動的に切り替え、これでミラーリングの時のようにand演算を使って割り算を行い、「ミラーリング」させています。

カートリッジとしての機能が殆ど有りませんが、まずはこれで十分でしょう。

最後に、バスでつなげます。

```cpp
inline uint8_t read(uint16_t addr) //from processor to subsystems.
{
  switch(addr & 0xE000){
    case 0x0000:
      return ram.read(addr);
        case 0x6000:
                return cartridge->readSram(addr); //追加
        case 0x8000:
        case 0xA000:
                return cartridge->readBankLow(addr); //追加
        case 0xC000:
        case 0xE000:
                return cartridge->readBankHigh(addr); //追加
    default:
      return 0; //TODO: まだたくさん残ってる
  }
}
inline void write(uint16_t addr, uint8_t value) // from processor to subsystems.
{
  switch(addr & 0xE000){
    case 0x0000:
      ram.write(addr, value);
      break;
        case 0x6000:
                cartridge->writeSram(addr, value); //追加
        case 0x8000:
        case 0xA000:
                cartridge->writeBankLow(addr, value); //追加
                break;
        case 0xC000:
        case 0xE000:
                cartridge->writeBankHigh(addr, value); //追加
                break;
    default:
      //TODO: まだたくさん残ってる
  }
}
```
ふ～。CPUを動かすための舞台装置が、これで完成です。

